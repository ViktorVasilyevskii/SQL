Задание 1
От разработчиков поступила задача: нужно выяснить, какие запросы шли на IP-адреса. 
IP-адрес состоит из четырёх чисел, они разделены точками. Тебе нужны адреса, которые начинаются с "233.201.".
Логи лежат на удалённом сервере по адресу logs/2019/12. День, когда случилась ошибка, неизвестен.
Твоя задача — узнать, какие запросы были отправлены.

РЕШЕНИЕ: grep -R "^233.201." ~/logs/2019/12

///

Задание 2
В системе обнаружен баг. Он проявлялся 30.12.2019 и 31.12.2019 с 21:30:00 до 21:39:59. 
При этом появлялись ошибки с номерами 400 и 500. Твоя задача — сохранить в отдельный файл логи, 
которые были записаны в этот период.
Затем эти логи надо разложить по отдельным файлам: логи с одинаковой ошибкой положи в один файл. 

Как это сделать:
В домашней директории на удалённом сервере создай директорию bug1.
Все запросы, которые произошли в указанный период, положи в файл main.txt.
Внутри директории bug1 создай директорию events.
Внутри директории events создай файлы для ошибок с номерами 400 и 500. 
Назови эти файлы 400.txt и 500.txt соответственно. 
В них выдели логи с соответствующей ошибкой из файла main.txt.

РЕШЕНИЕ: 
Команды, которые создают директории bug1 и events.
mkdir bug1
mkdir bug1/events
__________________

Команда, которой выбираешь запросы за указанный период. Это те запросы, которыми ты отбираешь логи в файл main.txt.
grep -R '3[0,1]/12/2019:21:3[0-9]:[0-5][0-9]' ~/logs/2019/12 > ~/bug1/main.txt
__________________

Команды, которыми ты кладёшь логи в файлы 400.txt и 500.txt из main.txt.
grep  '\"\s40[0-9]' ~/bug1/main.txt > ~/bug1/events/400.txt
grep  '\"\s50[0-9]' ~/bug1/main.txt > ~/bug1/events/500.txt

///

Задание 3
У тебя есть база данных с поездками на такси. По плану на линию обслуживания должно было выйти 
10550 автомобилей — эта цифра покрывает спрос пользователей. 
Команде поступило много жалоб — свободных автомобилей оказалось недостаточно. 
Сколько такси вышло на линии на самом деле? Информация о всех машинах на линии есть в таблице cabs.

РЕШЕНИЕ: SELECT COUNT(*) FROM cabs;

///

Задание 4
Посчитай количество автомобилей в каждой компании из таблицы cabs. 
Отсортируй значения по убыванию. 
Команда предполагает, что некоторые компании не вывели достаточно автомобилей на линию.
Выведи те компании, в которых меньше 100 автомобилей. Поле с числом автомобилей назови cnt, 
поле с названием компании — company_name.
Чтобы решить задачу, примени оператор HAVING — аналог WHERE для агрегирующих функций.

В ответе приложи:
Список компаний с числом автомобилей меньше 100.
Запрос, которым тебе удалось решить задачу.

РЕШЕНИЕ: 

SELECT company_name, 
COUNT(*) AS cnt 
FROM cabs 
GROUP BY company_name 
HAVING COUNT(*) < 100 ORDER BY cnt DESC;

///

Задание 5
В приложении такси рассчитывается коэффициент стоимости поездки. 
Если погода хорошая, значение коэффициента равно 1. 
Если на улице дождь или шторм, коэффициент повышается до 2. 
У команды есть гипотеза, что в расчётах коэффициента ошибка. 
Чтобы проверить расчёт коэффициента, команде нужна выборка данных: 
разработчик может сверить коэффицент с данными в логах и исправить баг. 
Твоя задача — получить выборку.

Чтобы это сделать:
Получи описание погодных условий из таблицы weather_records для каждого часа.
Раздели все часы на две группы оператором CASE: 'Bad', если поле description содержит слова rain или storm; 
'Good' для всех остальных. Полученное поле назови weather_conditions.
В результирующей таблице должно быть два поля — дата и час (ts) и weather_conditions.
Сделай выборку за период с 2017-11-05 00:00 по 2017-11-06 00:00.

РЕШЕНИЕ:

SELECT ts, 
CASE WHEN description LIKE '%rain%' 
OR  description LIKE ‘%storm%’ 
THEN 'Bad' 
ELSE 'Good'
END AS weather_conditions 
FROM weather_records 
WHERE ts::timestamp >='2017-11-05 00:00' 
AND ts::timestamp<='2017-11-06 00:00';

///

Задание 6
После обновления ПО таксопарки стали сообщать, что прибыль, которую они получают, не сходится с данными, 
которые отдаёт приложение. Разработка предполагает, что проблема может быть в данных о количестве поездок.
Чтобы определить, есть ли баг, нужно получить выборку с количеством поездок 
каждого таксопарка за 15 и 16 ноября 2017 года.
Выведи поле company_name. Поле с числом поездок назови trips_amount и выведи его.
Результаты, полученные в поле trips_amount отсортируй по убыванию.

SELECT cabs.company_name, 
COUNT(*) AS trips_amount 
FROM cabs 
INNER JOIN trips ON trips.cab_id = cabs.cab_id 
WHERE trips.start_ts::date>='2017-11-15' 
AND trips.end_ts::date<='2017-11-16' 
GROUP BY cabs.company_name ORDER
BY trips_amount DESC;
